using Microsoft.Extensions.DependencyInjection;
using SmartSpin.Dialogs;
using SmartSpin.Model;
using SmartSpin.Support;
using SmartSpin.ViewModel;
using System;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Xml;

namespace SmartSpin.Hardware
{
    /// <summary>
    /// These are the NETDATA registers into the NextMove
    /// </summary>
    public enum NetDataParam
    {
        Command = 1,
        HeadCommand = 3,  // 0 - do nothing, > 0 change to head.  (NextMove will reset to 0 once received)
        SpindleCommand = 4, // 0 - do nothing, 1 - Start, 2 - Stop
        CentreCommand = 5, // 0 - do nothing, 1 - Centre Up, 2 - Centre Down
        FrontFormerCommand = 6, // 0 - do nothing, 1 - Start Cycle (NextMove sets to 0 when complete)
        TopFormerCommand = 7, // 0 - do nothing, 1 - Start Cycle (NextMove sets to 0 when complete)
        BackStopCommand = 8, // 0 - do nothing, 1 - Start Cycle (NextMove sets to 0 when complete)
        FormerAutoCycleCommand = 9,  // 0 - do nothing, 1 - FrontFormer, 2 - TopFormer, 3 - Both

        Samples = 10,
        SamplePosition = 11,
        PlayBackSpeed = 12,    // 0 - 2 = 0 - 200%

        AxisJogSpeed = 20,
        FrontFormerFeed = 22,  // 0 - 100%   Analog output at slow down
        TopFormerFeed = 23,  // 0 - 100%   Analog output at slow down
        SpindleSpeed = 24,
        SpindleDirection = 25,
        FrontFormerTime = 26,  // Time in secs of how long it will hold the feed on
        TopFormerTime = 27,    // Time in secs of how long it will hold the feed on
        FrontFormerSpindleRPM = 28,
        TopFormerSpindleRPM = 29,

        SpindleStatus = 30,
        HydraulicCommandPosition = 31,
        SpindleDCBus = 33,
        SpindleLoad = 34,
        SpindleRPM = 35,
        MoveTo1 = 36,
        MoveTo2 = 37,
        UseBackStop = 38,

        AxisErr = 40,
        ErrorCode = 41,

        SpindleAccel = 50,
        SpindleDecel = 51,
        SpindleBraking = 52,

        HydraulicEncoder = 80,

        XJog = 101,
        ZJog = 102
    }

    /// <summary>
    /// Commands written to the acCommand COMMS
    /// </summary>
    public enum MotionCommands
    {
        Nothing = 0,
        AutoCycle = 1,
        AutoCycleComplete = 2,
        HomeCycle = 3,
        HomeCycleComplete = 4,
        RecordCycle = 5,
        CancelPlay = 6,

        MoveToCycle = 7,
        MoveToCycleComplete = 8,

        JogPlus = 10,
        JogMinus = 11,
        Error = 20,
        ResetErrors = 21,
        Shutdown = 22,
        EnableMachine = 23,  // switch safety relay on
        DisableMachine = 24, // switch off safety relay (Disables Machine)

        DownloadingRecord = 30,
        CalculateVFFTable = 31,
    }

    /// <summary>
    /// Errors that can be generated by the program
    /// </summary>
    public enum Errors
    {
        NoErrors, LightBeamTripped, EStopPressed, Overtravel, FollowingError,
        Drive1Fault, Drive2Fault, Drive3Fault, Drive4Fault, SpindleFault, HomingFault, MoveNotCompleted, CommunicationError
    }

    public enum NVMemory
    {
        Encoder1Direction = 1,    // 0 = normal, 1 = inverted
        Encoder2Direction = 2,    // 0 = normal, 1 = inverted
        DAC1Direction = 3,        // 0 = normal, 1 = inverted
        DAC2Direction = 4,        // 0 = normal, 1 = inverted
        HoldHeadSignal = 5,        // 0 = pulsed, 1 = held on
    }

    /// <summary>
    /// Sequence of auto cycle
    /// </summary>
    public enum PlaySequenceEnum
    {
        Idle, ToStartPos,
        WaitToStartPos, WaitMemory1,
        WaitToMemory2, WaitMemory2,
        WaitToMemory3, WaitMemory3,
        WaitToMemory4, WaitMemory4,
        WaitToMemory5, WaitMemory5,
        WaitToMemory6, WaitMemory6,
        WaitToMemory7, WaitMemory7,
        WaitToMemory8, WaitMemory8,
        WaitToMemory9, WaitMemory9,
        WaitToMemory10, WaitMemory10,
        WaitToReturnToStart, WaitToComplete,
        Complete
    };

    public static class Machine
    {

        private static readonly NLog.Logger logger = NLog.LogManager.GetCurrentClassLogger();

        private const int MintCommsDelay = 0;

        private static readonly string[] CErrorMessages = new string[] {
            "Machine OK.",
            "Safety System Tripped.",
            "E.Stop pressed.",
            "Table Reached Overtravel.",
            "Axis Outside Acceptable Tolerance.",
            "Drive 1 Fault.",
            "Drive 2 Fault.",
            "Drive 3 Fault.",
            "Drive 4 Fault.",
            "Spindle Drive Fault.",
            "Homing Fault. Hydraulic Cylinders not moving.",
            "Servo Axes not completed move.",
            "Lost communications link to controller board."};

        private const int iStartButton = 4;
        private const int iSafetyOK = 5;

        public static event EventHandler FinishedPlayBack;

        private static XmlDocument setupfile = new XmlDocument();
       public static bool Simulation { get; private set; } = true;
        public static string ControllerFirmwareVersion { get; private set; }

        private static bool PlayingStatus;
        private static Errors Error;
        public static bool FrontFormerAttached;
        public static bool TopFormerAttached = true;
        public static bool BackStopAttached;
        public static bool CenterAttached;
        public static bool CanChangeHead;
        public static bool HoldHeadSignal;

        public static Spindle SpindleAxis;

        public static Former TopFormer;

        public static ParametersViewModel Parameters;

        public static ControllerAxis[] Axes;

        public static ControllerAxis ZAxis, XAxis, BAxis, X1Axis, Y1Axis, Z1Axis;

        public static IServoDrive[] ServoDrive;

        public static int RecordedSamples { get; private set; }
        private static SampledProfile RecordStorage;

       private static PlaySequenceEnum PlaySequence;

        public static int ProfileIndex;

        public static int SelectedHeadNo;
        public static bool MachineHomed;
        public static bool StartPosOnly;
        public static bool Recording;
        public static bool Playing;
        public static bool Pausing;
        public static int SpindleStatus;
        public static int[] DriveStatus;
        //public static int[] DriveInputs;

        public static bool IsHolding;
        public static bool MachineOK;

        /// <summary>
        /// This is set to true if the Samples are uploaded or downloaded
        /// It stops the timer event logging an error because it's taking so long.
        /// </summary>
        public static bool LongOperation = false;

        public static SpinProgram CurrentProgram = new SpinProgram();

        // Number of memories that actually have spinning profiles
        static int SpinningMemories = 0;

        public static uint LastInput = 0;
        public static uint Inputs = 0;
        public static uint Outputs = 0;

        public static readonly uint[] bitc =
        [
            0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,
            0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 0x400000, 0x800000,
            0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000, 0x20000000, 0x4000, 0x80000000];

         internal static void SetOutputOn(int bit)
         {
             Outputs = (Outputs | bitc[bit]);
         }

         internal static bool IsOutputOn(int bit)
         {
             return ((Outputs & bitc[bit]) != 0);
         }

         internal static bool IsInputOn(int bit)
         {
             return ((Inputs & bitc[bit]) != 0);
         }

         internal static bool IsInputOff(int bit)
         {
             return ((Inputs & bitc[bit]) == 0);
         }

        internal static uint MintIn(short nBank)
        {
            if (Simulation) return 0;
            if (ServoDrive[nBank+2] is IServoVariableComms servo)
            {
                return servo.GetInputs();
            }
            return 0;
        }

        private static string setupfilename = String.Empty;

        internal static void SaveSetupFile()
        {
            setupfile.Save(setupfilename);
        }

        internal static bool setupReadBool(string item, bool defaultValue)
        {
            XmlNode foundNode = setupfile.SelectSingleNode(item);
            if (foundNode == null)
                return defaultValue;
            else
                return Convert.ToBoolean(foundNode.InnerXml);
        }

        internal static void setupWriteValue(string XPath, string NodeName, string value)
        {
            XmlNode xn = setupfile.SelectSingleNode(XPath);
            // if no node Path was found then just ignore it
            if (xn == null) return;

            XmlNode xne = setupfile.SelectSingleNode(XPath + "/" + NodeName);
            // child wasn't found so create it
            if (xne == null)
            {
                XmlElement newElem = setupfile.CreateElement(NodeName);
                xn.AppendChild(newElem);
            }
            xne = setupfile.SelectSingleNode(XPath + "/" + NodeName);
            if (xne != null)
            {
                xne.InnerText = value;
                using (XmlTextWriter writer = new XmlTextWriter(setupfilename, Encoding.UTF8))
                {
                    writer.Formatting = Formatting.Indented;
                    setupfile.Save(writer);
                }
            }
        }

        internal static Controller CreateController(IServiceProvider _serviceProvider, XmlDocument setupfile, string node)
        {
            XmlNode foundNode = setupfile.SelectSingleNode(node);
            if (foundNode == null)
            {
                return null;
            }
            Controller controller = _serviceProvider.GetRequiredService<Controller>();

            foundNode = setupfile.SelectSingleNode($"{node}/IP");
            if (foundNode != null)
            {
                controller.SetEthernetControllerLink(foundNode.InnerXml);
            }
            else
            {
                foundNode = setupfile.SelectSingleNode($"{node}/USBNode");
                if (foundNode != null)
                {
                    short Node = short.Parse(foundNode.InnerXml);
                    controller.SetUSBControllerLink(Node);
                }
                else
                {
                    foundNode = setupfile.SelectSingleNode($"{node}/ControllerVirtual");
                    if (foundNode != null)
                    {
                        controller.SetVirtualControllerLink();
                    }
                }
            }

            if (controller.Connected)
            {
                ControllerFirmwareVersion = controller.FirmwareVersion;

                if (!controller.Virtual)
                {
                    if (!controller.MintExecuting && !Simulation)
                    {
                        controller.DoMintRun();
                        Thread.Sleep(2000); // give it time to startup
                    }
                }
            }
            else
            {
                Simulation = true;
            }
            return controller;
        }

        internal static void SetupLink(IServiceProvider _serviceProvider, string SetupFileName)
        {
            setupfilename = SetupFileName;
            setupfile.Load(setupfilename);

            Parameters = new ParametersViewModel(setupfile.SelectSingleNode("setup/Machine"));

            XmlNode foundNode = setupfile.SelectSingleNode("setup/Machine/TotalAxes");
            Globals.TotalAxes = Convert.ToInt32(foundNode.InnerXml);

            FrontFormerAttached = Parameters.CreateParameter("FrontFormerAttached", false);
            TopFormerAttached = Parameters.CreateParameter("TopFormerAttached", false);
            CenterAttached = Parameters.CreateParameter("CenterAttached", false);
            CanChangeHead = Parameters.CreateParameter("CanChangeHead", false);
            BackStopAttached = Parameters.CreateParameter("BackStopAttached", false);
            bool DontHome = Parameters.CreateParameter("DontHome", false);
            HoldHeadSignal = Parameters.CreateParameter("HoldHeadSignal", false);

            MachineHomed = DontHome;

            if (Globals.TotalAxes < 1)
                throw new SpinningException($"System is unable to support {Globals.TotalAxes} axes");

            Simulation = Parameters.CreateParameter("Simulate", false);
            
            if (Simulation)
                MyMessageBox.ShowError("Unable to communicate with motion controller.  Putting CNC program into simulation mode.", "Communication Error");

            Axes = new ControllerAxis[Globals.MAX_AXES];
            ServoDrive = new IServoDrive[Globals.MAX_AXES];
            DriveStatus = new int[Globals.MAX_AXES];
            for (int i = 0; i < Globals.MAX_AXES; i++)
            {
                foundNode = setupfile.SelectSingleNode($"setup/axis{i}");
                if (foundNode == null)
                {
                    //Axes[i] = new ControllerAxis(controller, foundNode, i);
                    break;
                }
                else
                {
                    var controller = CreateController(_serviceProvider, setupfile, $"setup/axis{i}");

                    XmlNode servoNode = foundNode.SelectSingleNode("Servo");
                    string ServoType = String.Empty;
                    if (servoNode != null)
                    {
                        ServoType = servoNode.InnerXml;
                    }
                    switch (ServoType.ToUpper()) {
                        case "ABB" :
                            ABBDrive abb = new ABBDrive(controller, foundNode, i);
                            ServoDrive[i] = abb;
                            Axes[i] = abb;
                            break;
                        case "DELTA" :
                            DeltaDrive delta = new DeltaDrive(controller, foundNode, i);
                            ServoDrive[i] = delta;
                            Axes[i] = delta;
                            break;
                        case "HYDRAULIC":
                            Axes[i] = new HydraulicAxis(controller, foundNode, i);
                            break;
                        default:
                            Axes[i] = new ControllerAxis(controller, foundNode, i);
                            break;
                    }
                    if (ServoDrive[i] != null)
                    {
                        ServoDrive[i].Open(Simulation);
                        if (ServoDrive[i].Simulation && !Simulation)
                            MyMessageBox.Show($"Unable to communicate with {Axes[i].Letter} Servo Drive.  Putting CNC program into simulation mode.");
                        if (!DontHome)
                        {
                            if (!ServoDrive[i].Homed) MachineHomed = false;
                        }
                    }
                }
                if ("Z".Equals(Axes[i].Letter))
                {
                    ZAxis = Axes[i];
                }
                if ("X".Equals(Axes[i].Letter))
                {
                    XAxis = Axes[i];
                }
                if ("B".Equals(Axes[i].Letter))
                {
                    BAxis = Axes[i];
                }
                if ("X1".Equals(Axes[i].Letter))
                {
                    X1Axis = Axes[i];
                }
                if ("Y1".Equals(Axes[i].Letter))
                {
                    Y1Axis = Axes[i];
                }
                if ("Z1".Equals(Axes[i].Letter))
                {
                    Z1Axis = Axes[i];
                }
            }

            var spindleController = CreateController(_serviceProvider, setupfile, "setup/Spindle");
            SpindleAxis = new Spindle(spindleController, setupfile.SelectSingleNode("setup/Spindle"));
            TopFormer = new Former(setupfile.SelectSingleNode("setup/TopFormer"));
            if (!Simulation)
            {
                DownloadParameters();
            }

            PlaySequence = PlaySequenceEnum.Idle;
            SelectedHeadNo = 1;
        }

        private static void MintNetFloat(NetDataParam param, float value)
        {
            if (Simulation) return;
            for(int i  = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] is IServoVariableComms servo)
                {
                    servo.MintNetFloat(param, value);
                }
            }
        }

        private static void MintNetInteger(NetDataParam param, int value)
        {
            if (Simulation) return;
            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] is IServoVariableComms servo)
                {
                    servo.MintNetInteger(param, value);
                }
            }
        }

        private static int MintNetInteger(NetDataParam param)
        {
            if (Simulation) return 0;
            if (ServoDrive[2] is IServoVariableComms servo)
            {
                return servo.MintNetInteger(param);
            }
            return 0;
        }

        private static float MintNetFloat(NetDataParam param)
        {
            if (Simulation) return 0;
            if (ServoDrive[2] is IServoVariableComms servo)
            {
                return servo.MintNetFloat(param);
            }
            return 0;
        }

        public static void MintVariableData(string paramName, object value)
        {
            try
            {
                if (ServoDrive[2] is IServoVariableComms servo)
                {
                    servo.SetVariableData(paramName, value);
                }
            }
            catch (Exception e)
            {
                logger.Error(e, $"MintVariableData writing {paramName}");
                MyMessageBox.ShowError($"{e.Message} writing {paramName}", "Mint Writing Error");
            }
        }

        public static int MintVariableInt32(string paramName)
        {
            if (Simulation) return 0;
            if (ServoDrive[2] is IServoVariableComms servo)
            {
                return servo.ReadVariableInt32(paramName);
            }
            return 0;
        }

        public static double MintVariableFloat(string paramName)
        {
            if (Simulation) return 0;
            if (ServoDrive[2] is IServoVariableComms servo)
            {
                return servo.ReadVariableFloat(paramName);
            }
            return 0;
        }

        public static object MintVariableData(string paramName)
        {
            try
            {
                if (ServoDrive[2] is IServoVariableComms servo)
                {
                    return servo.GetVariableData(paramName);
                }
            }
            catch (Exception e)
            {
                logger.Error(e, $"MintVariableData writing {paramName}");
                MyMessageBox.ShowError($"{e.Message} writing {paramName}", "Mint Writing Error");
            }
            return null;
        }



        private static bool? metric;
        public static bool Metric
        {
            get
            {
                metric ??= setupReadBool("setup/Machine/Metric", true);
                return metric ?? true;
            }
            set
            {
                metric = value;
                setupWriteValue("setup/Machine", "Metric", metric.ToString());
            }
        }

        private static double CalculateFormerTime(int FormerCycle, double FromSpindleRPM, double ToSpindleRPM)
        {
            //TODO: CalculateFormerTime
            double FormerTime = 0;
            //if ((FormerCycle == FormerCycleEnum.Front) | (FormerCycle == FormerCycleEnum.FrontFirst))
            //{
            //    FormerTime = FormerTime + SpindleAxis.SpeedChangeTime(FromSpindleRPM, CurrentProgram.FrontFormerSpindleRPM);
            //    FormerTime = FormerTime + CurrentProgram.FrontFormerTime + 4000;
            //    if (FormerCycle == FormerCycleEnum.FrontFirst)
            //        FormerTime = FormerTime + SpindleAxis.SpeedChangeTime(CurrentProgram.FrontFormerSpindleRPM, CurrentProgram.TopFormerSpindleRPM);
            //    else
            //        FormerTime = FormerTime + SpindleAxis.SpeedChangeTime(CurrentProgram.FrontFormerSpindleRPM, ToSpindleRPM);
            //}
            //if ((FormerCycle == FormerCycleEnum.Top) | (FormerCycle == FormerCycleEnum.TopFirst))
            //{
            //    if ((FormerCycle == FormerCycleEnum.Top) | (FormerCycle == FormerCycleEnum.TopFirst))
            //        FormerTime = FormerTime + SpindleAxis.SpeedChangeTime(FromSpindleRPM, CurrentProgram.TopFormerSpindleRPM);
            //    FormerTime = FormerTime + CurrentProgram.TopFormerTime + 4000;
            //    if (FormerCycle == FormerCycleEnum.TopFirst)
            //        FormerTime = FormerTime + SpindleAxis.SpeedChangeTime(CurrentProgram.TopFormerSpindleRPM, ToSpindleRPM);
            //    else
            //        FormerTime = FormerTime + SpindleAxis.SpeedChangeTime(CurrentProgram.TopFormerSpindleRPM, ToSpindleRPM);
            //}

            //if (FormerCycle == FormerCycleEnum.TopFirst)
            //{
            //    FormerTime = FormerTime + CurrentProgram.FrontFormerTime + 4000;
            //    FormerTime = FormerTime + SpindleAxis.SpeedChangeTime(CurrentProgram.FrontFormerSpindleRPM, ToSpindleRPM);
            //}
            return FormerTime;
        }

        internal static void UploadNewVFFTable(int axisno)
        {
            HydraulicAxis ha = Axes[axisno] as HydraulicAxis;
            ha.UploadNewVFFTable();
        }

        internal static void DownloadParameters()
        {
            if (Simulation) return;
            for (int i = 0; i < 2; i++)
            {
                if (Axes[i] is HydraulicAxis ha)
                {
                    ha.DownloadParameters(HoldHeadSignal);
                }
            }
        }

        internal static void Shutdown()
        {
            if (Simulation) return;
            MintNetInteger(NetDataParam.Command, (int)MotionCommands.Shutdown);
        }

        public static void DownloadSamples(SampledProfile Source)
        {
            if (Simulation) return;

            float[] cSamples1 = new float[Source.TotalSamples + 1];
            float[] cSamples2 = new float[Source.TotalSamples + 1];

            // Store the size of the sample array in the first index of array
            cSamples1[0] = Source.TotalSamples;
            cSamples2[0] = Source.TotalSamples;

            for (int sample = 0; sample < Source.TotalSamples; sample++)
            {
                cSamples1[sample + 1] = (float)Source.AxisStorage[0][sample];
                cSamples2[sample + 1] = (float)Source.AxisStorage[1][sample];
            }

            LongOperation = true;

            if (Axes[0] is HydraulicAxis ha1)
            { 
                ha1.DownloadSamples(cSamples1);
            }
            if (Axes[1] is HydraulicAxis ha2)
            {
                ha2.DownloadSamples(cSamples2);
            }
        }


        public static void SetPlaybackSpeed(double PlayBackSpeed)
        {
            if (Simulation) return;
            MintNetFloat(NetDataParam.PlayBackSpeed, (float)PlayBackSpeed);
        }

        public static void MoveServo(int axisno, double DestinationPosition)
        {
            logger.Info($"Move Servo {axisno} Pos {DestinationPosition}");
            ServoDrive[axisno].MoveTo(DestinationPosition);
        }

        public static void TransferProgramSettings()
        {
            UseBackStop(CurrentProgram.UseBackStopDevice);
            //SetFrontFormerSpeed(CurrentProgram.FrontFormerSpeed);
            //SetFrontFormerTime(CurrentProgram.FrontFormerTime);
            //SetFrontFormerSpindleRPM(CurrentProgram.FrontFormerSpindleRPM);
            //SetTopFormerSpeed(CurrentProgram.TopFormerSpeed);
            //SetTopFormerTime(CurrentProgram.TopFormerTime);
            //SetTopFormerSpindleRPM(CurrentProgram.TopFormerSpindleRPM);
            SetSpindleDieSize(CurrentProgram.SpindleDieSize);
        }

        public static void SetProfiling(bool OnOff)
        {
        }

        public static void ResetDriveErrors()
        {
            if (!Simulation) MintNetInteger(NetDataParam.Command, (int)MotionCommands.ResetErrors);
            logger.Info("cmdResetErrors");
            foreach (var sd in ServoDrive)
            {
                if (sd != null) sd.ResetErrors();
            }
            Thread.Sleep(500);
            Error = Errors.NoErrors;
            Inputs = MintIn(0);
            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] != null)
                {
                    DriveStatus[i] = ServoDrive[i].DriveStatus();
                    //DriveInputs[i] = ServoDrive[i].DriveInputs();
                }
            }

            SpindleStatus = SpindleAxis.Status;
            CheckForErrors(false);
        }

        private static Errors DoCheck(bool PreTest)
        {
            if ((Error == Errors.LightBeamTripped) & IsInputOn(iSafetyOK))
            {
                return Errors.NoErrors;
            }

            // exit with an existing error
            if (Error != Errors.NoErrors) return Error;

            if (Simulation)
            {
                logger.Fatal("Communications Error");
                return Errors.CommunicationError;
            }

            foreach (var sd in ServoDrive)
            {
                if (sd != null)
                {
                    if (sd.Simulation)
                    {
                        logger.Fatal("No communications with Servo Drive");
                        return Errors.CommunicationError;
                    }
                }
            }
            if (((Playing) | (Recording) | (PreTest)) & (IsInputOff(iSafetyOK)))
            {
                logger.Fatal("Light Beam Tripped");
                return Errors.LightBeamTripped;
            }
            //  if (Playing or Recording or PreTest) and IsInputOff(iControllerEnabled)  { FErrors = EStopPressed; return; }
            //  if (Playing or Recording) and
            //    (IsInputOn(iOvertravel1Plus) or IsInputOn(iOvertravel1Minus) or IsInputOn(iOvertravel2Plus) or IsInputOn(iOvertravel2Minus)) 
            //       { FErrors = Overtravel; return; }

            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] != null)
                {
                    if (ServoDrive[i].IsDriveInFault(DriveStatus[i]))
                    {
                        logger.Fatal($"Axis {i} Drive Fault. Status {(int)DriveStatus[i]:X8}");
                        return Errors.Drive1Fault+(i-2);
                    }

                    if (ServoDrive[i].ProgramError() > 0)
                    {
                        logger.Fatal($"Axis {i} Drive Error {ServoDrive[i].ProgramError()}");
                        return Errors.Drive1Fault+(i-2);
                    }
                }
            }

            //  if PreTest and // (Playing or Recording or Homing or PreTest) and
            if ((SpindleAxis.Status & 0x8) == 0x8)
            {
                logger.Fatal($"Spindle Fault {SpindleStatus}");
                return Errors.SpindleFault;
            }

            return Errors.NoErrors;
        }

        public static void CheckForErrors(bool PreTest)
        {
            Error = DoCheck(PreTest);
            MachineOK = (Error == Errors.NoErrors);
        }

        public static Errors MachineErrors
        {
            get
            {
                if (Simulation) Error = Errors.CommunicationError;
                return Error;
            }
        }

        public static string ErrorMessage
        {
            get
            {
                if (IsInputOn(iSafetyOK))
                    return CErrorMessages[(int)Error] + "  (Machine Enabled)";
                else
                    return CErrorMessages[(int)Error] + "  (Machine Disabled)";
            }
        }

        public static double CurPosition(int axisno)
        {
            if (Simulation) return 0;
            if (Axes[axisno] is HydraulicAxis ha)
            {
                return ha.ActualPosition;
            }
            return ServoDrive[axisno].ActualPosition();
        }

        public static double CommandPosition(int axisno)
        {
            if (Simulation) return 0;
            if (Axes[axisno] is HydraulicAxis ha)
            {
                return ha.CommandPosition;
            }
            return ServoDrive[axisno].TargetPosition();
        }

        public static int FollowingError(int axisno)
        {
            if (Simulation) return 0;
            return ServoDrive[axisno].PositionError();
        }

        public static int PlayBackPointer
        {
            get
            {
                if (Simulation)
                    return 0;
                else
                    return MintNetInteger(NetDataParam.SamplePosition);
            }
        }

        public static int RecordPointer
        {
            get
            {
                if (Simulation)
                    return 0;
                else
                    return MintNetInteger(NetDataParam.Samples);
            }
        }

        public static void TuneAxis(int axisno)
        {
            if (Simulation) return;
            if (Axes[axisno] is HydraulicAxis ha)
            {
                ha.MintNetInteger(NetDataParam.Command, (int)MotionCommands.CalculateVFFTable);
            }
        }

        public static void ChangeHead(int HeadNo)
        {
            SelectedHeadNo = HeadNo;
            if (Simulation) return;

            logger.Info($"cmdHeadCommand={HeadNo}");
            MintNetInteger(NetDataParam.HeadCommand, HeadNo);
        }

        public static void CentreUp()
        {
            if (Simulation) return;

            logger.Info("cmdCentreCommand=1");
            MintNetInteger(NetDataParam.CentreCommand, 1);
        }

        public static void CentreDown()
        {
            if (Simulation) return;

            logger.Info("cmdCentreCommand=2");
            MintNetInteger(NetDataParam.CentreCommand, 2);
        }

        public static void BackStopCycle()
        {
            if (Simulation) return;

            logger.Info("cmdBackStopCommand=1");
            MintNetInteger(NetDataParam.BackStopCommand, 1);
        }

        public static void FrontFormerCycle()
        {
            if (Simulation) return;

            logger.Info("cmdFrontFormerCommand=1");
            MintNetInteger(NetDataParam.FrontFormerCommand, 1);
        }

        public static void TopFormerCycle()
        {
            if (Simulation) return;

            logger.Info("cmdTopFormerCommand=1");
            MintNetInteger(NetDataParam.TopFormerCommand, 1);
        }

        public static void BackStopIn()
        {
            if (Simulation) return;

            logger.Info("cmdBackStopCommand=2");
            MintNetInteger(NetDataParam.BackStopCommand, 2);
        }

        public static void UseBackStop(bool Yes)
        {
            if (Simulation) return;
            if (Yes)
                MintNetInteger(NetDataParam.UseBackStop, 1);
            else
                MintNetInteger(NetDataParam.UseBackStop, 0);
        }

        public static void FrontFormerIn()
        {
            if (Simulation) return;

            logger.Info("cmdFrontFormerCommand=2");
            MintNetInteger(NetDataParam.FrontFormerCommand, 2);
        }

        public static void TopFormerIn()
        {
            if (Simulation) return;

            logger.Info("cmdTopFormerCommand=1");
            MintNetInteger(NetDataParam.TopFormerCommand, 2);
        }

        //public static void SetFrontFormerSpeed(double Speed)
        //{
        //    if (Simulation) return;

        //    MintNetFloat(NetDataParam.FrontFormerFeed, (float)Speed);
        //}

        //public static void SetFrontFormerSpindleRPM(int Speed)
        //{
        //    if (Simulation) return;

        //    MintNetFloat(NetDataParam.FrontFormerSpindleRPM, (float)(Speed * 1.5));
        //}

        //public static void SetFrontFormerTime(double Time)
        //{
        //    if (Simulation) return;

        //    MintNetFloat(NetDataParam.FrontFormerTime, (float)Time);
        //}

        //public static void SetTopFormerSpeed(double Speed)
        //{
        //    if (Simulation) return;

        //    MintNetFloat(NetDataParam.TopFormerFeed, (float)Speed);
        //}

        //public static void SetTopFormerTime(double Time)
        //{
        //    if (Simulation) return;

        //    MintNetFloat(NetDataParam.TopFormerTime, (float)Time);
        //}

        //public static void SetTopFormerSpindleRPM(int Speed)
        //{
        //    if (Simulation) return;

        //    MintNetFloat(NetDataParam.TopFormerSpindleRPM, (float)(Speed * 1.5));
        //}

        public static void Jog(int axisno, int Output)
        {
            if (Simulation) return;
            if (Axes[axisno].SwapJogButtons)
            {
                Output = -Output;
            }
            if (Output == 0)
            {
                if (Axes[axisno] is HydraulicAxis ha)
                {
                    ha.MintNetInteger(NetDataParam.Command, (int)MotionCommands.Nothing);
                }
                else
                {
                    ServoDrive[axisno].JogStop();
                }
                logger.Info("{axisno}.JogStop", axisno);
            }
            else
            {
                if (Axes[axisno] is HydraulicAxis ha)
                {
                    ha.MintNetFloat(NetDataParam.AxisJogSpeed, Math.Abs(Output));
                    ha.MintNetInteger(NetDataParam.Command, Output > 0 ? (int)MotionCommands.JogPlus : (int)MotionCommands.JogMinus);
                    logger.Info("cmdJog{axisno}", axisno);
                }
                else
                {
                    if (Output > 0)
                        ServoDrive[axisno].JogPlus(Math.Abs(Output));
                    else
                        ServoDrive[axisno].JogMinus(Math.Abs(Output));
                    logger.Info("Servo[{axisno}].Jog (Speed {Output})", axisno, Output);
                }
            }
        }

        public static bool StartButtonPressed()
        {
            return IsInputOn(iStartButton);
        }

        public static void HoldEnableOn(bool HoldOn)
        {
            IsHolding = HoldOn;
            foreach (var sd in ServoDrive)
            {
                sd?.HoldEnableOn(HoldOn);
            }
        }

        public static void EnableMachine()
        {
            if (!(Simulation))
            {
                if (Error == Errors.LightBeamTripped) Error = Errors.NoErrors;
                MintNetInteger(NetDataParam.Command, (int)MotionCommands.EnableMachine);
                logger.Info("cmdEnableMachine");
                Stopwatch sw = new Stopwatch();
                sw.Start();
                // Wait at least 0.5sec for (the Safety to come on
                do
                {
                    Thread.Sleep(0);
                    Inputs = MintIn(0);
                } while ((IsInputOff(iSafetyOK)) & (sw.ElapsedMilliseconds < 500));
            }
        }

        public static void DisableMachine()
        {
            if (!(Simulation)) MintNetInteger(NetDataParam.Command, (int)MotionCommands.DisableMachine);
            logger.Info("cmdDisableMachine");
        }

        public static double CalculateServoTime(int MemNo)
        {
            double MoveServoTime;
            double MoveServoTimeMax = 0;
            int MaxM = CurrentProgram.MemoriesUsed;

            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] != null)
                {
                    if (MemNo == 1)
                        MoveServoTime = ServoDrive[i].TimeToMove(CommandPosition(i), CurrentProgram.MemS[1].TargetPositions[i]);
                    else
                    {
                        if (MemNo == MaxM)
                            MoveServoTime = ServoDrive[i].TimeToMove(CurrentProgram.MemS[MaxM].TargetPositions[i], CurrentProgram.MemS[1].TargetPositions[i]);
                        else
                            MoveServoTime = ServoDrive[i].TimeToMove(CurrentProgram.MemS[MemNo - 1].TargetPositions[i], CurrentProgram.MemS[MemNo].TargetPositions[i]);
                    }
                    if (MoveServoTime > MoveServoTimeMax) MoveServoTimeMax = MoveServoTime;
                }
            }
            return MoveServoTimeMax;
        }

        /// <summary>
        /// Calculate time to complete the whole program in msecs
        /// </summary>
        /// <returns>time in msecs</returns>
        public static double CalculateProgramTime()
        {
            double Move1Time;
            double Move2Time;
            double MoveTime;
            double SpindleTime;
            double FormerTime;

            double TotalTime = 0;
            int MaxM = CurrentProgram.MemoriesUsed;
            
            // first caculate the time it will take to do the actual spinning
            for (int MemNo = 1; MemNo <= MaxM; MemNo++)
            {
                TotalTime = TotalTime + (CurrentProgram.MemS[MemNo].TotalSamples * (100 / CurrentProgram.MemS[MemNo].PlaybackSpeed));
            }
            TotalTime = TotalTime * (100 / CurrentProgram.MemS[0].PlaybackSpeed);
            // Convert the samples to msecs
            TotalTime = TotalTime * Globals.RecordSample * 1000;

            // Add on time between memories
            for (int MemNo = 1; MemNo <= MaxM; MemNo++)
            {
                SpindleTime = SpindleAxis.SpeedChangeTime(CurrentProgram.MemS[MemNo - 1].SpindleSpeed, CurrentProgram.MemS[MemNo].SpindleSpeed);
                FormerTime = CalculateFormerTime(CurrentProgram.MemS[MemNo - 1].FormerCycle, CurrentProgram.MemS[MemNo - 1].SpindleSpeed, CurrentProgram.MemS[MemNo].SpindleSpeed);

                if (MemNo == 1)
                {
                    Move1Time = Axes[0].TimeToMove(CommandPosition(0), CurrentProgram.MemS[MemNo].AxisStorage[0][0]);
                    Move2Time = Axes[1].TimeToMove(CommandPosition(1), CurrentProgram.MemS[MemNo].AxisStorage[1][0]);
                }
                else
                {
                    Move1Time = Axes[0].TimeToMove(CurrentProgram.MemS[MemNo - 1].AxisStorage[0][0], CurrentProgram.MemS[MemNo].AxisStorage[0][0]);
                    Move2Time = Axes[1].TimeToMove(CurrentProgram.MemS[MemNo - 1].AxisStorage[1][0], CurrentProgram.MemS[MemNo].AxisStorage[1][0]);
                }
                MoveTime = CalculateServoTime(MemNo);
                if (SpindleTime > MoveTime) MoveTime = SpindleTime;
                if (Move1Time > MoveTime) MoveTime = Move1Time;
                if (Move2Time > MoveTime) MoveTime = Move2Time;
                if (FormerTime > MoveTime) MoveTime = FormerTime;

                TotalTime = TotalTime + MoveTime + 200;  // add a bit extra
            }

            // Back to Start position
            SpindleTime = SpindleAxis.SpeedChangeTime(CurrentProgram.MemS[MaxM].SpindleSpeed, CurrentProgram.MemS[0].SpindleSpeed);
            FormerTime = CalculateFormerTime(CurrentProgram.MemS[MaxM].FormerCycle, CurrentProgram.MemS[MaxM].SpindleSpeed, CurrentProgram.MemS[0].SpindleSpeed);

            Move1Time = Axes[0].TimeToMove(CurrentProgram.MemS[MaxM].AxisStorage[0][0], CurrentProgram.MemS[1].AxisStorage[0][0]);
            Move2Time = Axes[1].TimeToMove(CurrentProgram.MemS[MaxM].AxisStorage[1][0], CurrentProgram.MemS[1].AxisStorage[1][0]);

            MoveTime = CalculateServoTime(MaxM);
            if (SpindleTime > MoveTime) MoveTime = SpindleTime;
            if (Move1Time > MoveTime) MoveTime = Move1Time;
            if (Move2Time > MoveTime) MoveTime = Move2Time;
            if (FormerTime > MoveTime) MoveTime = FormerTime;

            TotalTime = TotalTime + MoveTime + 200;  // add a bit extra

            return TotalTime;
        }

        private static readonly double[] MovePos = new double[Globals.MAX_AXES];

        public static void TriggerFormerCycle(int mem)
        {
            int cycleNumber = CurrentProgram.MemS[mem].FormerCycle;
            if (cycleNumber > 0)
            {
                FormerProfile fp = CurrentProgram.FormerCycles[cycleNumber-1];
                MintNetFloat(NetDataParam.TopFormerSpindleRPM, (float)fp.SpindleSpeed);

                if (fp.FormerMoves.Count > 0)
                {
                    float[] FormerZPosition = new float[fp.FormerMoves.Count];
                    float[] FormerZSpeed = new float[fp.FormerMoves.Count];
                    float[] FormerYPosition = new float[fp.FormerMoves.Count];
                    float[] FormerYSpeed = new float[fp.FormerMoves.Count];
                    int[] FormerDelay = new int[fp.FormerMoves.Count];

                    for (int i = 0; i < fp.FormerMoves.Count; i++)
                    {
                        FormerZPosition[i] = (float)(fp.FormerMoves[i].HPosition * TopFormer.HAxis.DisplayMultiplier);
                        FormerZSpeed[i] = (float)(fp.FormerMoves[i].HSpeed * TopFormer.HAxis.MaxVelocity / 100);
                        FormerYPosition[i] = (float)(fp.FormerMoves[i].VPosition * TopFormer.VAxis.DisplayMultiplier);
                        FormerYSpeed[i] = (float)(fp.FormerMoves[i].VSpeed * TopFormer.VAxis.MaxVelocity / 100);
                        FormerDelay[i] = (int)(fp.FormerMoves[i].Delay*1000);
                    }
                    MintVariableData("FormerZPosition", FormerZPosition);
                    MintVariableData("FormerZSpeed", FormerZSpeed);
                    MintVariableData("FormerYPosition", FormerYPosition);
                    MintVariableData("FormerYSpeed", FormerYSpeed);
                    MintVariableData("FormerDelay", FormerDelay);
                }
                MintVariableData("FormerLineCount", fp.FormerMoves.Count);
                MintNetInteger(NetDataParam.FormerAutoCycleCommand, cycleNumber);
            }
        }

        public static void StartMoveToMemoryPlayback(int MemNo, bool LastMemory = false)
        {
            if (!StartPosOnly)
            {
                if (LastMemory)
                {
                    TriggerFormerCycle(CurrentProgram.MemoriesUsed);
                }
                else
                {
                    TriggerFormerCycle(MemNo - 1);
                }

                if (LastMemory)
                    SpindleAxis.CommandSpeed = CurrentProgram.MemS[0].SpindleSpeed;
                else
                    SpindleAxis.CommandSpeed = CurrentProgram.MemS[MemNo].SpindleSpeed;
            }

            ChangeHead(CurrentProgram.MemS[MemNo].HeadNumber);

            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] != null)
                {
                    if (ServoDrive[i].MoveBetweenMemories)
                    {
                        MovePos[i] = CurrentProgram.MemS[MemNo].TargetPositions[i] + CurrentProgram.MemS[MemNo].Offsets[i] + CurrentProgram.MemS[0].Offsets[i];
                        MoveServo(i, MovePos[i]);
                    }
                }
            }

            SampledProfile PlaybackStorage = new SampledProfile(true);
            // Move from where it is to start pos
            PlaybackStorage.AxisStorage[0] = (Axes[0] as HydraulicAxis).MakeAMove(CurPosition(0), CurrentProgram.MemS[MemNo].AxisStorage[0][0]);
            PlaybackStorage.AxisStorage[1] = (Axes[1] as HydraulicAxis).MakeAMove(CurPosition(1), CurrentProgram.MemS[MemNo].AxisStorage[1][0]);
            PlaybackStorage.TrimSamples(true, 0.25);

            SetPlaybackSpeed(1);
            DownloadSamples(PlaybackStorage);
            StartPlayback();
        }

        private static bool LastPlayStatus;
        private static bool LastSpindleAtSpeed;
        private static readonly bool[] LastMoveComplete = new bool[Globals.MAX_AXES];
        private static int LastFormerAutoCycle;
        private static int MemoryBeingPlayed = 0;

        public static void StartMemoryPlayback(int MemNo)
        {
            MemoryBeingPlayed = MemNo;
            SetPlaybackSpeed((CurrentProgram.MemS[0].PlaybackSpeed * CurrentProgram.MemS[MemNo].PlaybackSpeed) / 10000);
            DownloadSamples(CurrentProgram.MemS[MemNo]);
            SpindleAxis.CommandSpeed = CurrentProgram.MemS[MemNo].SpindleSpeed;
            StartPlayback();
        }

        // Check it has finished playing memory, axes are in position, spindle is up to speed, etc
        public static bool FinishedMoves()
        {
            bool CurrentPlayStatus = PlayingStatus;
            bool CurrentSpindleAtSpeed = SpindleAxis.AtSpeed;
            bool[] CurrentMoveComplete = new bool[Globals.MAX_AXES];
            int CurrentFormerAutoCycle = MintNetInteger(NetDataParam.FormerAutoCycleCommand);
            bool MovesNotEqual = false;

            // If we are moving the start pos we don"t need to check if spindle is up to speed
            bool Result = (!CurrentPlayStatus);

            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] != null)
                {
                    if (ServoDrive[i].MoveBetweenMemories)
                    {
                        CurrentMoveComplete[i] = ServoDrive[i].MoveComplete();
                        Result &= CurrentMoveComplete[i];
                        if (CurrentMoveComplete[i] != LastMoveComplete[i]) MovesNotEqual = true;
                    }
                }
            }

            Result &= (CurrentFormerAutoCycle == 0);

            if (!StartPosOnly)
            {
                if (MemoryBeingPlayed <= SpinningMemories)
                {
                    Result &= CurrentSpindleAtSpeed;
                }
            }
            if ((CurrentPlayStatus != LastPlayStatus) | (CurrentSpindleAtSpeed != LastSpindleAtSpeed) | (MovesNotEqual) | (CurrentFormerAutoCycle != LastFormerAutoCycle))
            {
                logger.Info($"PlayingStatus : {CurrentPlayStatus}  Spindle At Speed : {CurrentSpindleAtSpeed}  Move Complete 2 : {CurrentMoveComplete[2]}  Move Complete 3 : {CurrentMoveComplete[3]}  Move Complete 4 : {CurrentMoveComplete[4]}  Former Cycle Status : {CurrentFormerAutoCycle}");
            }
            LastPlayStatus = CurrentPlayStatus;
            LastSpindleAtSpeed = CurrentSpindleAtSpeed;

            for (int i = 2; i < Globals.TotalAxes; i++) LastMoveComplete[i] = CurrentMoveComplete[i];

            LastFormerAutoCycle = CurrentFormerAutoCycle;

            return Result;
        }



        // After FinishedMoves returns true it does a final check
        // to make sure it is in the right position.
        // If not it stops with an error
        private static bool CheckServosAtCorrectPosition(out string logMessage)
        {
            logMessage = String.Empty;
            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] != null)
                {
                    if (ServoDrive[i].MoveBetweenMemories)
                    {
                        double positionError = Math.Abs(ServoDrive[i].ActualPosition() - MovePos[i]) / Axes[i].DisplayMultiplier;
                        if (positionError > Axes[i].Tolerance)
                        {
                            logMessage = $"Servo Not In Position : AX{i} Pos {ServoDrive[i].ActualPosition() / Axes[i].DisplayMultiplier} to {MovePos[i] / Axes[i].DisplayMultiplier}  Pos Error {positionError}";
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        private static bool ServosAtCorrectPosition()
        {
            string logMessage = String.Empty;
            if (CheckServosAtCorrectPosition(out logMessage))
            {
                return true;
            }
            Thread.Sleep(1000);
            if (CheckServosAtCorrectPosition(out logMessage))
            {
                return true;
            }
            logger.Fatal(logMessage);
            CancelPlay();
            Error = Errors.MoveNotCompleted;
            return false;
        }

        public static void ResetPlaybackSequence()
        {
            PlaySequence = PlaySequenceEnum.ToStartPos;
        }

        public static void CheckPlayBack()
        {
            PlaySequenceEnum CurrentSequence = PlaySequence;
            switch (PlaySequence)
            {
                case PlaySequenceEnum.ToStartPos:
                    HoldEnableOn(true);
                    StartMoveToMemoryPlayback(1);
                    PlaySequence++; // move to next sequence
                    Thread.Sleep(100);
                    break;
                case PlaySequenceEnum.WaitToStartPos:
                    if (FinishedMoves())
                    {
                        if (StartPosOnly)
                            PlaySequence = PlaySequenceEnum.Complete;
                        else
                            PlaySequence++;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory1:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(1);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory2:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 1)
                        {
                            StartMoveToMemoryPlayback(2);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory2:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(2);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory3:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 2)
                        {
                            StartMoveToMemoryPlayback(3);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory3:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(3);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory4:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 3)
                        {
                            StartMoveToMemoryPlayback(4);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory4:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(4);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory5:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 4)
                        {
                            StartMoveToMemoryPlayback(5);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory5:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(5);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory6:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 5)
                        {
                            StartMoveToMemoryPlayback(6);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory6:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(6);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory7:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 6)
                        {
                            StartMoveToMemoryPlayback(7);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory7:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(7);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory8:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 7)
                        {
                            StartMoveToMemoryPlayback(8);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory8:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(8);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory9:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 8)
                        {
                            StartMoveToMemoryPlayback(9);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory9:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(9);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToMemory10:
                    if (FinishedMoves())
                    {
                        if (CurrentProgram.MemoriesUsed > 9)
                        {
                            StartMoveToMemoryPlayback(10);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                        else
                            PlaySequence = PlaySequenceEnum.WaitToReturnToStart;
                    }
                    break;
                case PlaySequenceEnum.WaitMemory10:
                    if (FinishedMoves())
                    {
                        if (ServosAtCorrectPosition())
                        {
                            StartMemoryPlayback(10);
                            PlaySequence++; // move to next sequence
                            Thread.Sleep(100);
                        }
                    }
                    break;
                case PlaySequenceEnum.WaitToReturnToStart:
                    if (FinishedMoves())
                    {
                        StartMoveToMemoryPlayback(1, true);
                        PlaySequence++; // move to next sequence
                        Thread.Sleep(100);
                    }
                    break;
                case PlaySequenceEnum.WaitToComplete:
                    if (FinishedMoves())
                    {
                        PlaySequence++; // move to next sequence
                        Thread.Sleep(100);
                    }
                    break;
                //    psComplete
            }
            if (CurrentSequence != PlaySequence)
            {
                logger.Info(PlayingStatusString());
            }
        }

        public static string PlayingStatusString()
        {
            return PlaySequence.ToString();
        }

        public static void StartPlayback()
        {
            if (Simulation) return;
            MintNetInteger(NetDataParam.Command, (int)MotionCommands.AutoCycle);
            logger.Info("cmdAutoCycle");
            SpinningMemories = CurrentProgram.CalculateSpinningMemories();

            Playing = true;
            PlayingStatus = true;
        }

        public static void CancelPlay()
        {
            if (Simulation) return;
            HoldEnableOn(false);
            MintNetInteger(NetDataParam.Command, (int)MotionCommands.CancelPlay);
            logger.Info("cmdCancelPlay");
            PlaySequence = PlaySequenceEnum.Idle;
        }

        public static void StartRecord()
        {
            if (!Simulation)
            {
                MintNetInteger(NetDataParam.Command, (int)MotionCommands.RecordCycle);
                logger.Info("cmdRecordCycle");
                HoldEnableOn(true);
            }
            Recording = true;
            RecordStorage = new SampledProfile(true);
        }

        public static void StopRecord()
        {
            if (!Simulation)
            {
                MintNetInteger(NetDataParam.Command, (int)MotionCommands.DownloadingRecord);
                logger.Info("cmdDownloadingRecord");
                HoldEnableOn(false);
                Thread.Sleep(100);
            }
            Recording = false;
        }

        public static void CheckRecording()
        {
        }

        public static void UploadRecording(SampledProfile MemStorage)
        {
            float[] cSamples1 = [];
            float[] cSamples2 = [];

            if (Simulation)
            {
                RecordedSamples = 20;
                for (int sample = 0; sample < 20; sample++)
                {
                    RecordStorage.AxisStorage[0].Add(sample);
                    RecordStorage.AxisStorage[1].Add(sample);
                }
                MemStorage.Assign(RecordStorage);
                return;
            }

            RecordedSamples = MintNetInteger(NetDataParam.Samples);

            if (Axes[0] is HydraulicAxis ha1)
            {
                cSamples1 = ha1.UploadSamples()[0..RecordedSamples];
            }
            if (Axes[1] is HydraulicAxis ha2)
            {
                cSamples2 = ha2.UploadSamples()[0..RecordedSamples];
            }

            for (int sample = 0; sample < RecordedSamples; sample++)
            {
                RecordStorage.AxisStorage[0].Add(cSamples1[sample]);
                RecordStorage.AxisStorage[1].Add(cSamples2[sample]);
            }

            logger.Info($"Recorded {RecordedSamples} Samples.");
            RecordStorage.TrimSamples(false);
            logger.Info($"Saved Samples after Trim {RecordStorage.AxisStorage[0].Count} Samples.");
            logger.Info("cmdNothing");
            MintNetInteger(NetDataParam.Command, (int)MotionCommands.Nothing);
            MemStorage.Assign(RecordStorage);
        }

        private static void OnFinishedPlayBack()
        {
            FinishedPlayBack?.Invoke(null, EventArgs.Empty);
        }

        public static void UpdateStatus()
        {
            if (Simulation) return;
            LongOperation = false;
            Inputs = MintIn(0);
            if (Inputs != LastInput)
            {
                LastInput = Inputs;
                logger.Info($"Inputs {Inputs:X5}");
            }

            for (int i = 2; i < Globals.TotalAxes; i++)
            {
                if (ServoDrive[i] != null)
                {
                    DriveStatus[i] = ServoDrive[i].DriveStatus();
                    //DriveInputs[i] = ServoDrive[i].DriveInputs();
                }
            }

            SpindleStatus = SpindleAxis.Status;
            Thread.Sleep(MintCommsDelay);
            MotionCommands currentCommand = (MotionCommands)MintNetInteger(NetDataParam.Command);
            Thread.Sleep(MintCommsDelay);
            PlayingStatus = (currentCommand == MotionCommands.AutoCycle) | (currentCommand == MotionCommands.MoveToCycle);
            CheckForErrors(false);
            MachineOK = (Error == Errors.NoErrors);
            if ((!MachineOK) & (IsHolding)) HoldEnableOn(false);
            CheckPlayBack();
            if ((PlaySequence == PlaySequenceEnum.Complete) & (Playing))
            {
                PlaySequence = PlaySequenceEnum.Idle;
                HoldEnableOn(false);
                OnFinishedPlayBack();
            }
            Playing = (PlaySequence != PlaySequenceEnum.Idle);
        }

        public static void ReadVFFTables()
        {
            (Axes[0] as HydraulicAxis).ReadVFFTable();
            (Axes[1] as HydraulicAxis).ReadVFFTable();
        }

        /// <summary>
        /// Set the Die size of the spindle. This will set the Spindle Accel/Decel/Braking parameters
        /// </summary>
        /// <param name="dieSize"></param>
        internal static void SetSpindleDieSize(int dieSize)
        {
            SpindleAxis.SetDieSize(dieSize);
        }
    }
}
